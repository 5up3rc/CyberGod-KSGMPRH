// SWAMI KARUPPASWAMI THUNNAI

#include<Windows.h>
#include<thread>
#include"conversions.h"
#include"extensions.h"
#include"malware.h"
#include"headers.h"
#include"utilities.h"
#include <boost/filesystem.hpp>
#include"malware_symptoms.h"
#include<export.h>


// At present we do follow three rules 
// Rule 1:
// If the hash matches then it is a threat
// Rule 2:
// If the executable is packed with UPX then it is a threat
// Rule 3
// Checks whether the string matches in the exe
// The rule-set will be explained in the code too

template<typename malwares>
bool Malware<malwares>::scan(const wchar_t *sDir)
{
	init();
	WIN32_FIND_DATA find_file;
	HANDLE hFind = NULL;
	wchar_t current_path[2048];

	// Use the specific extensions for scanning 
	Extensions check_extensions;

	 
	wsprintf(current_path, L"%s\\*.*", sDir);

	if ((hFind = FindFirstFile(current_path, &find_file)) == INVALID_HANDLE_VALUE)
	{
		wprintf(L"Path not found: [%s]\n", sDir);
		return false;
	}

	do
	{
		
		if (wcscmp(find_file.cFileName, L".") != 0
			&& wcscmp(find_file.cFileName, L"..") != 0)
		{
			
			wsprintf(current_path, L"%s\\%s", sDir, find_file.cFileName);

			
			if (find_file.dwFileAttributes &FILE_ATTRIBUTE_DIRECTORY)
			{
				scan(current_path);  
			}
			else {
				// [Local member-instance variable] boost enabled
				bool can_scan = false;
				//This consists of current path
				malwares Path = wide_char_to_wide_string(current_path);
				boost::filesystem::path p = { Path };
				// we got the extension of the file
				std::string extension = p.extension().string();
				// if boost scan enabled
				if (return_boost_scan_status() == true)
				{
					if (check_extensions.is_common_extension(extension) == true) can_scan = true;
				}
				// If boost is enabled and the extension is ok then scan and if boost is disabled then scan
				if (can_scan == true || return_boost_scan_status() == false)
				{
					if (check_extensions.is_common_extension(extension) == true)
					{
						// Increments the scanned file count
						increment_file_count();
						std::cout << "File: " << Path << "\n" << "extension: " << extension << "\n";
						// md5 hash of the file is stored here
						std::string hash = calculate_md5(wide_char_to_wide_string(current_path));
						std::cout << "Hash: " << hash << "\n";
						// Rule 1
						// checks in the database whether the hash matches or not and adds to the list
						if (check_in_database(hash) == true)
						{
							std::cout << "\nHash Malicious Executable" << Path << "\n";
							add_suspicious_files_to_list(Path, "Suspicious[IDENTIFIED] executables");
						}
						// Rule 2
						// Checks whether the executable is packed with UPX or not
						if (is_upx(Path))
						{
							std::cout << "\nMalicious Executable" << Path << "\n";
							add_suspicious_files_to_list(Path, "Suspicious[PACKED] executables");
						}
						// Rule 3
						// Checks whether the string matches in the exe
						if (extension == ".exe")
						{
							if (is_string_present(0, Path))
							{
								std::cout << "\nMalicious Executable";
								add_suspicious_files_to_list(Path, "Suspicious Semi-Declared");
								int a;
								std::cin >> a;
							}
						}
						std::cout << "\nFiles scanned " << return_file_count() << "\n";
					}
					else
					{
						std::cout << "Scheduling this path\n";
						add_to_schedule(Path);
					}
				}
			}
		}
	} while (FindNextFile(hFind, &find_file));

	FindClose(hFind);

	return true;
}

template<typename malwares>
std::string Malware<malwares>::start_hashing(malwares file_location)
{
	std::string hash = calculate_md5(file_location);
	file_count++;
	return hash;
}


// Increment the scanned files count
template<typename malwares>
void Malware<malwares>::increment_file_count()
{
	file_count++;
}

// return the current file count
template<typename malwares>
long double Malware<malwares>::return_file_count()
{
	return file_count;
}

// will help us to know whether the boost scan status is enabled or not
template<typename malwares>
bool Malware<malwares>::return_boost_scan_status()
{
	return is_boost_enabled;
}

// set help you select your choice whether to boost the scan or not
template<typename malwares>
void Malware<malwares>::set_boost_scan(bool set_scan_speed)
{
	is_boost_enabled = set_scan_speed;
}

// used for scanning the scheduled files
template<typename malwares>
void Malware<malwares>::scan_scheduled_files()
{
	// Scheduling is done only when the booster is disabled
	if (is_boost_enabled == false)
	{
		if (!schedule_list.empty())
		{
			typedef std::set<malwares>::iterator iterator;
			iterator itr1 = schedule_list.begin();
			iterator itr2 = schedule_list.end();
			for (iterator itr = itr1; itr != itr2; ++itr)
			{
				if (std::ifstream(*itr))
				{
					// we will get the MD5 hash
					std::string hash = calculate_md5(*itr);
					std::cout << "Scheduled Scan Hash: " << hash << "\n";
					// Rule 1
					// checks in the database whether the hash matches or not and adds to the list
					if (check_in_database(hash) == true)
					{
						std::cout << "\nHash Malicious Executable" << *itr << "\n";
						add_suspicious_files_to_list(*itr, "Suspicious[IDENTIFIED] executables");
					}
					// Rule 2
					// Checks whether the executable is packed with UPX or not
					if (is_upx(*itr))
					{
						std::cout << "\nMalicious Executable" << *itr << "\n";
						add_suspicious_files_to_list(*itr, "Suspicious[PACKED] executables");
					}
					std::cout << "\nFiles scanned " << return_file_count() << "\n";
				}
			}
		}
	}
}

// this function will add the suspicious files which is found to be malicious to the list
template<typename malwares>
bool Malware<malwares>::add_suspicious_files_to_list(malwares location, std::string type)
{
	typedef std::map<malwares, std::string>::iterator iterator;
	iterator find = suspicious_files_list.find(location);
	if (find == suspicious_files_list.end())
	{
		suspicious_files_list[location] = type;
		return true;
	}
	return false;
}

// display the suspicios files to the user => this will be modified by the GUI dev
template<typename malwares>
void Malware<malwares>::display_suspicious_files()
{
	system("cls");
	typedef std::map<malwares, std::string>::iterator iterator;
	iterator itr1 = suspicious_files_list.begin();
	iterator itr2 = suspicious_files_list.end();
	std::cout << "Malicious Detections\n=============================\n";
	for (iterator itr = itr1; itr != itr2; ++itr)
	{
		std::cout << itr->first << "\t\t" << itr->second << "\n";
	}
}

// Adding to schedule for scanning later
template<typename malwares>
bool Malware<malwares>::add_to_schedule(malwares location)
{
	try
	{
		schedule_list.insert(location);
		return true;
	}
	catch (std::exception &e)
	{
		std::cout << e.what();
	}
	return false;
}

template class Malware<std::wstring>;
