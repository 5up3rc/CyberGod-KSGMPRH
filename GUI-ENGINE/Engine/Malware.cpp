// SWAMI KARUPPASWAMI THUNNAI

#include<Windows.h>
#include<thread>
#include"conversions.h"
#include"extensions.h"
#include"malware.h"
#include"headers.h"
#include"utilities.h"
#include <boost/filesystem.hpp>
#include"malware_symptoms.h" 

template<typename malwares>
bool Malware<malwares>::CheckIsStopped()
{
    if (isStopped)
    {
        return isStopped(IsStoppedContext);
    }
    return false;
}

// At present we do follow two rules 
// Rule 1:
// If the hash matches then it is a threat
// Rule 2:
// If the executable is packed with UPX then it is a threat

// The rule-set will be explained in the code too

template<typename malwares>
bool Malware<malwares>::scan(const wchar_t *sDir)
{
	WIN32_FIND_DATA find_file;
	HANDLE hFind = NULL;
	wchar_t current_path[2048];    

	// Use the specific extensions for scanning 
	Extensions check_extensions;

	//Specify a file mask. *.* = We want everything! 
	wsprintf(current_path, L"%s\\*.*", sDir);

	if ((hFind = FindFirstFile(current_path, &find_file)) == INVALID_HANDLE_VALUE)
	{
        if (OnError)
        {
            wchar_t errorMessage[2048];
            wsprintf(errorMessage, L"Path not found: [%s]\n", sDir);
            OnError(OnErrorContext, errorMessage, 1);
        }
		return false;
	}

	do
	{
		//Find first file will always return "."
		//    and ".." as the first two directories. 
		if ((wcscmp(find_file.cFileName, L".") != 0
			&& wcscmp(find_file.cFileName, L"..") != 0) && !CheckIsStopped())
		{
			//Build up our file path using the passed in 
			//  [sDir] and the file/foldername we just found: 
			wsprintf(current_path, L"%s\\%s", sDir, find_file.cFileName);

			//Is the entity a File or Folder? 
			if ((find_file.dwFileAttributes &FILE_ATTRIBUTE_DIRECTORY) && !CheckIsStopped())
			{
				scan(current_path); //Recursion, I love it! 
			}
			else {
                try
                {
                    // [Local member-instance variable] boost enabled
                    bool can_scan = false;
                    //This consists of current path
                    malwares Path = wide_char_to_wide_string(current_path);
                    boost::filesystem::path p = { Path };
                    // we got the extension of the file
                    std::string extension = p.extension().string();


                    // if boost scan enabled
                    if (return_boost_scan_status() == true)
                    {
                        if (check_extensions.is_common_extension(extension) == true) can_scan = true;
                    }
                    // If boost is enabled and the extension is ok then scan and if boost is disabled then scan
                    if (can_scan == true || return_boost_scan_status() == false)
                    {
                        if (check_extensions.is_common_extension(extension) == true)
                        {
                            // Increments the scanned file count
                            increment_file_count();
                            //std::cout << "File: " << Path << "\n" << "extension: " << extension << "\n";
                            // md5 hash of the file is stored here
                            std::string hash = calculate_md5(wide_char_to_wide_string(current_path));
                            // std::cout << "Hash: " << hash << "\n";
                            if (OnNewFile)
                            {
                                std::wstring fileExtension(extension.begin(), extension.end());
                                std::wstring fileHash(hash.begin(), hash.end());

                                OnNewFile(OnNewFileContext, current_path, fileExtension.c_str(), fileHash.c_str());
                            }

                            // Rule 1
                            // checks in the database whether the hash matches or not and adds to the list
                            if (check_in_database(hash) == true)
                            {
                                //std::cout << "\nHash Malicious Executable" << Path << "\n";
                                if (OnMalicious)
                                {
                                    OnMalicious(OnMaliciousContext, current_path, MALICIOUS_IDENTIFID);
                                }
                                add_suspicious_files_to_list(Path, "Suspicious[IDENTIFIED] executables");
                            }
                            // Rule 2
                            // Checks whether the executable is packed with UPX or not
                            if (is_upx(Path))
                            {
                                //std::cout << "\nMalicious Executable" << Path << "\n";
                                if (OnMalicious)
                                {
                                    OnMalicious(OnMaliciousContext, current_path, MALICIOUS_PACKED);
                                }
                                add_suspicious_files_to_list(Path, "Suspicious[PACKED] executables");
                            }
                            //
                            std::cout << "\nFiles scanned " << return_file_count() << "\n";
                        }
                        else
                        {
                            if (OnScheduled)
                            {
                                OnScheduled(OnScheduledContext, current_path, SCHEDULED_NORMAL);
                            }
                            //std::cout << "Scheduling this path\n";
                            add_to_schedule(Path);
                        }
                    }
                }
                catch (std::exception& ex)
                {
                    if (OnError)
                    {
                        std::string what(ex.what());
                        std::wstring strError(what.begin(), what.end());
                        OnError(OnErrorContext, strError.c_str(), 11);
                    }
                }
			}
		}
	} while (FindNextFile(hFind, &find_file) && !CheckIsStopped());

	FindClose(hFind);

	return true;
}

template<typename malwares>
std::string Malware<malwares>::start_hashing(malwares file_location)
{
	std::string hash = calculate_md5(file_location);
	file_count++;
	return hash;
}


// Increment the scanned files count
template<typename malwares>
void Malware<malwares>::increment_file_count()
{
	file_count++;
}

// return the current file count
template<typename malwares>
long double Malware<malwares>::return_file_count()
{
	return file_count;
}

// will help us to know whether the boost scan status is enabled or not
template<typename malwares>
bool Malware<malwares>::return_boost_scan_status()
{
	return is_boost_enabled;
}

// set help you select your choice whether to boost the scan or not
template<typename malwares>
void Malware<malwares>::set_boost_scan(bool set_scan_speed)
{
	is_boost_enabled = set_scan_speed;
}

// used for scanning the scheduled files
template<typename malwares>
void Malware<malwares>::scan_scheduled_files()
{
	// Scheduling is done only when the booster is disabled
	if (is_boost_enabled == false && !CheckIsStopped())
	{
		if (!schedule_list.empty() && !CheckIsStopped())
		{
			typedef std::set<malwares>::iterator iterator;
			iterator itr1 = schedule_list.begin();
			iterator itr2 = schedule_list.end();
			for (iterator itr = itr1; itr != itr2 && !CheckIsStopped(); ++itr)
			{
				if (std::ifstream(*itr))
				{
					// we will get the MD5 hash
					std::string hash = calculate_md5(*itr);
					//std::cout << "Scheduled Scan Hash: " << hash << "\n";

                    if (OnNewFile)
                    {
                        std::wstring current_path = *itr;

                        std::wstring fileExtension(L"?");
                        std::wstring fileHash(hash.begin(), hash.end());

                        OnNewFile(OnNewFileContext, current_path.c_str(), fileExtension.c_str(), fileHash.c_str());
                    }

					// Rule 1
					// checks in the database whether the hash matches or not and adds to the list
					if (check_in_database(hash) == true)
					{                        
						//std::cout << "\nHash Malicious Executable" << *itr << "\n";
                        if (OnMalicious)
                        {
                            std::wstring current_path = *itr;
                            OnMalicious(OnMaliciousContext, current_path.c_str(), MALICIOUS_IDENTIFID);
                        }
						add_suspicious_files_to_list(*itr, "Suspicious[IDENTIFIED] executables");
					}
					// Rule 2
					// Checks whether the executable is packed with UPX or not
					if (is_upx(*itr))
					{                        
						//std::cout << "\nMalicious Executable" << *itr << "\n";
                        if (OnMalicious)
                        {
                            std::wstring current_path = *itr;
                            OnMalicious(OnMaliciousContext, current_path.c_str(), MALICIOUS_PACKED);
                        }
						add_suspicious_files_to_list(*itr, "Suspicious[PACKED] executables");
					}
					//std::cout << "\nFiles scanned " << return_file_count() << "\n";
				}
			}
		}
	}
}

// this function will add the suspicious files which is found to be malicious to the list
template<typename malwares>
bool Malware<malwares>::add_suspicious_files_to_list(malwares location, std::string type)
{
	typedef std::map<malwares, std::string>::iterator iterator;
	iterator find = suspicious_files_list.find(location);
	if (find == suspicious_files_list.end())
	{
		suspicious_files_list[location] = type;
		return true;
	}
	return false;
}

// display the suspicios files to the user => this will be modified by the GUI dev
template<typename malwares>
void Malware<malwares>::display_suspicious_files()
{
	system("cls");
	typedef std::map<malwares, std::string>::iterator iterator;
	iterator itr1 = suspicious_files_list.begin();
	iterator itr2 = suspicious_files_list.end();
	std::cout << "Malicious Detections\n=============================\n";
	for (iterator itr = itr1; itr != itr2; ++itr)
	{
		std::cout << itr->first << "\t\t" << itr->second << "\n";
	}
}

// Adding to schedule for scanning later
template<typename malwares>
bool Malware<malwares>::add_to_schedule(malwares location)
{
	try
	{
		schedule_list.insert(location);
		return true;
	}
	catch (std::exception &e)
	{
		std::cout << e.what();
	}
	return false;
}

template class Malware<std::wstring>;